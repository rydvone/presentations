[task](https://github.com/rolling-scopes-school/tasks/blob/master/tasks/presentation.md)

- [YouTube video](youtube.com)  
- [presentation's deploy]()  
- [transcript presentation]()  

---  

## JWT
---  
JWT - 

Для начала рассмотрим понятия Аутентификация и Авторизация

Аутентификация(authentication) - это процесс проверки учётных данных пользователя (логин/пароль). Проверка подлинности пользователя путём сравнения введённого им логина/пароля с данными сохранёнными в базе данных.
Авторизация(authorization) - это проверка прав пользователя на доступ к определенным ресурсам.

Например, после аутентификации юзер sasha получает право обращаться и получать от ресурса "super.com/vip" некие данные. Во время обращения юзера sasha к ресурсу vip система авторизации проверит имеет ли право юзер обращаться к этому ресурсу (проще говоря переходить по неким разрешенным ссылкам)

1-Юзер c емайлом sasha_gmail.com успешно прошел аутентификацию
2-Сервер посмотрел в БД какая роль у юзера
3-Сервер сгенерил юзеру токен с указанной ролью
4-Юзер заходит на некий ресурс используя полученный токен
5-Сервер смотрит на права(роль) юзера в токене и соответственно пропускает или отсекает запрос
Собственно п.5 и есть процесс авторизации.

Как правило, при использовании JSON-токенов в клиент-серверных приложениях реализована следующая схема:
1-Клиент проходит аутентификацию в приложении (к примеру, с использованием логина и пароля)
2-В случае успешной аутентификации сервер отправляет клиенту access- и refresh-токены.
3-При дальнейшем обращении к серверу клиент использует access-токен. Сервер проверяет токен на валидность и предоставляет клиенту доступ к ресурсам
4-В случае, если access-токен становится невалидным, клиент отправляет refresh-токен, в ответ на который сервер предоставляет два обновленных токена.
5-В случае, если refresh-токен становится невалидным, клиент опять должен пройти процесс аутентификации (п. 1).[4]


Дабы не путаться с понятиями Authentication/Authorization можно использовать псевдонимы checkPassword/checkAccess()
AccessToken - имеет малое время жизни, и является многоразовым, его добавляют к каждому последующему запросу
RefreshToken - имеет большое время жизни, и является одноразовым, его используют для обновление пары токенов

или (2-й вариант)
Клиент вводит логин и пароль.
Сервер проверяет их, и если они верны, высылает в ответе JWT-токен.
Далее клиент высылает JWT-токен при каждом последующем запросе к серверу в заголовке Authorization
Сервер проверяет JWT-токен на подлинность.
И высылает ответ.

JWT-токен 
-Выдается он клиенту после успешного ввода имени и пароля.
-С последующими запросами клиент отправляет его серверу в заголовке, сервер проверяет его подлинность путем простой калькуляции. Удостоверяется что клиент есть  тот, за кого себя выдает.
-JWT-токен продолжает работать и после того, как сервер перезапущен.
-JWT-токен работает, если серверов несколько (с балансировщиком нагрузки). На конкретный сервер ничего не завязано: сессий нет, данных, хранящихся в сессии нет.

JSON Web Token (JWT) — содержит три блока, разделенных точками: заголовок(header), набор полей (payload) и сигнатуру. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Сигнатура может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

Токены предоставляют собой средство авторизации для каждого запроса от клиента к серверу. Токены(и соответственно сигнатура токена) генерируются на сервере основываясь на секретном ключе(который хранится на сервере) и payload'e. Токен в итоге хранится на клиенте и используется при необходимости авторизации какого-либо запроса. Такое решение отлично подходит при разработке SPA.

При попытке хакером подменить данные в header'ре или payload'е, токен станет не валидным, поскольку сигнатура не будет соответствовать изначальным значениям. А возможность сгенерировать новую сигнатуру у хакера отсутствует, поскольку секретный ключ для зашифровки лежит на сервере.

access token - используется для авторизации запросов и хранения дополнительной информации о пользователе (аля user_id, user_role или еще что либо, эту информацию также называет payload). Все поля в payload это свободный набор полей необходимый для реализации вашей частной бизнес логики. То бишь user_id и user_role не являются требованием и представляют собой исключительно частный случай. Сам токен храним не в localStorage как это обычно делают, а в памяти клиентского приложения.

refresh token - выдается сервером по результам успешной аутентификации и используется для получения новой пары access/refresh токенов. Храним исключительно в httpOnly куке.
AccessToken - имеет малое время жизни, и является многоразовым, его добавляют к каждому последующему запросу
RefreshToken - имеет большое время жизни, и является одноразовым, его используют для обновление пары токенов

Роль рефреш токенов и зачем их хранить в БД. Рефреш на сервере хранится для учета доступа и инвалидации краденых токенов. Таким образом сервер наверняка знает о клиентах которым стоит доверять(кому позволено авторизоваться). Если не хранить рефреш токен в БД то велика вероятность того что токены будут бесконтрольно гулять по рукам злоумышленников. Для отслеживания которых нам придется заводить черный список и периодически чистить его от просроченных. В место этого мы храним лимитированный список белых токенов для каждого юзера отдельно и в случае кражи у нас уже есть механизм противодействия(описано ниже).


!! Структура JWT


!! Как проверяется подлинность токена
Берется заголовок, полезная нагрузка и секретный ключ, из них вычисляется некоторое значение — подпись.

Секретный ключ хранится на стороне сервера. С помощью него подпись вычисляется при первоначальной выдаче токена, и с помощью него же перевычисляется каждый раз, когда приходит токен (иначе говоря, токен проверяется на валидность). Если значение вычисленной подписи совпадает с тем, что в токене, то токен считается валидным.  Это принцип поверки, аналогичный тому, что используется с Simple Hash-Based Remember-Me токеном. Только как видите, для JWT не надо даже обращаться к базе и находить пароль пользователя, чтобы вычислить подпись. Пароль в калькуляцию не входит, формула такая:

HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  секретный_ключ
)
Важно понять, что JWT-токен на сервере не хранится, а просто каждый раз проверяется на подлинность с помощью вышеприведенной формулы.

Хранится только секретный ключ — он един для всех JWT-токенов, выпускаемых приложением.

!! В каком заголовке передается JWT-токен
Принято передавать его так:

Authorization: Bearer <token>